<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept id="select_statement_results"> 
  <title>SELECT Statement Results</title> 
  <prolog audience="basic"> 
  </prolog> 
  <conbody> 
	 <section id="section_224D036544774EDD8182ED5FDD731E01"> 
		<p>The result of a SELECT statement is either UNDEFINED or is a 
		  <codeph>Collection</codeph> that implements the 
		  <codeph>com.gemstone.gemfire.cache.query.SelectResults</codeph>
		  interface. 
		</p> 
		<p>A SELECT statement returns a result, so it can be composed with other
		  expressions, like this: 
		  <codeblock>(SELECT DISTINCT * FROM /portfolios WHERE status = 'active').size</codeblock> 
		</p> 
		<p>The 
		  <codeph>SelectResults</codeph> returned from the SELECT statement is
		  either: 
		<ol id="ol_EDD51A8A1CBF47D2BECCD0C234B4013F"> 
		  <li id="li_ABE3598AF9554A22A95E48FE30A70236">A collection of objects,
			 returned for these two cases: 
			 <ol id="ol_A1DF974670C84AF6A298288791A8A56A"> 
				<li id="li_8D95687B52BF47DE8BD69097DFE09DF2">When only one
				  expression is specified by the projection list and that expression is not
				  explicitly specified using the fieldname:expression syntax 
				</li> 
				<li id="li_0188F2C30FC047B4876EC4A3724611C8">When the SELECT list
				  is 
				  <codeph>*</codeph> and a single collection is specified in the
				  FROM clause 
				</li> 
			 </ol> 
		  </li> 
		  <li id="li_251177AC7BE84788994E0F01574509EF">A collection of 
			 <codeph>Struct</codeph>s that contains the objects. 
		  </li> 
		</ol> 
		</p> 
		<p>When a struct is returned, the name of each field in the struct is
		  determined following this order of preference: 
		<ol id="ol_78F9376CA0B14514841C84F92CE76651"> 
		  <li id="li_3A5AAE0902BE4C0882679E5937EA3312">If a field is specified
			 explicitly using the fieldname:expression syntax, the fieldname is used. 
		  </li> 
		  <li id="li_9AED676BB3504125A7C3988073EF69B4">If the SELECT projection
			 list is 
			 <codeph>*</codeph> and an explicit iterator expression is used in the
			 FROM clause, the iterator variable name is used as the field name. 
		  </li> 
		  <li id="li_C47785A227DA4E11B986AA167F1ED2BF">If the field is associated
			 with a region or attribute path, the last attribute name in the path is used. 
		  </li> 
		  <li id="li_3C1BA5BFCFE047E0BC776B667675C280">If names can not be
			 decided based on these rules, arbitrary unique names are generated by the query
			 processor. 
		  </li> 
		</ol> 
		</p> 
		<p>Here are some examples of how projections and FROM clause expressions
		  are applied: 
		<table id="table_D7E89399C11749058F8427001A4DCCBA"> 
		  <tgroup cols="2"> 
			 <colspec colname="1" colnum="1" colwidth="*"/> 
			 <colspec colname="2" colnum="2" colwidth="*"/> 
			 <tbody> 
				<row> 
				  <entry> 
					 <codeblock>SELECT DISTINCT *
FROM /portfolios
WHERE status = 'active'</codeblock> 
				  </entry> 
				  <entry>Returns the 
					 <codeph>Collection</codeph> of active portfolios. 
				  </entry> 
				</row> 
				<row> 
				  <entry> 
					 <codeblock>IMPORT cacheRunner.Position;
SELECT DISTINCT secId
FROM /portfolios, positions.values TYPE Position
WHERE status = 'active'</codeblock> 
				  </entry> 
				  <entry>Returns the 
					 <codeph>Collection</codeph> of 
					 <codeph>secId</codeph>s from the positions of active
					 portfolios. 
				  </entry> 
				</row> 
				<row> 
				  <entry> 
					 <codeblock>IMPORT cacheRunner.Position;
SELECT DISTINCT secIdFieldName:secId
FROM /portfolios, positions.values TYPE Position
WHERE status = 'active'</codeblock> 
				  </entry> 
				  <entry>Returns the 
					 <codeph>Collection</codeph> of 
					 <codeph>struct&lt;secIdField: String&gt;</codeph> for the
					 active portfolios. (Compare to the results for the prior query.) 
				  </entry> 
				</row> 
				<row> 
				  <entry> 
					 <codeblock>SELECT DISTINCT "type", positions
FROM /portfolios
WHERE status = 'active'</codeblock> 
				  </entry> 
				  <entry>Returns a 
					 <codeph>Collection</codeph> of 
					 <codeph>struct&lt;type: String, positions: map&gt;</codeph> for
					 the active portfolios. The second field of the struct is a 
					 <codeph>Map</codeph> (<codeph>jav.utils.Map</codeph>) object,
					 which contains the positions map as the value. 
				  </entry> 
				</row> 
				<row> 
				  <entry> 
					 <codeblock>IMPORT cacheRunner.Position;
SELECT DISTINCT *
FROM /portfolios, positions.values TYPE Position
WHERE status = 'active'</codeblock> 
				  </entry> 
				  <entry>Returns a 
					 <codeph>Collection</codeph> of 
					 <codeph>struct&lt;portfolios: Portfolio, values:
						Position&gt;</codeph> for the active portfolios. 
				  </entry> 
				</row> 
				<row> 
				  <entry> 
					 <codeblock>IMPORT cacheRunner.Position;
SELECT DISTINCT *
FROM /portfolios pflo, positions posn TYPE Position
WHERE pflo.status = 'active'</codeblock> 
				  </entry> 
				  <entry>Returns a 
					 <codeph>Collection</codeph> of 
					 <codeph>struct&lt;pflo: Portfolio, posn: Position&gt;</codeph>
					 for the active portfolios. 
				  </entry> 
				</row> 
			 </tbody> 
		  </tgroup> 
		</table> 
		</p> 
	 </section> 
	 <section id="section_73B7C1E704AC4733AC7877CB62C51AF9"> 
		<title>Limiting the Number of Results</title> 
		<p>The LIMIT keyword can be optionally placed at the end of the query
		  string to limit the number of rows returned. For example, this query returns at
		  most 10 rows: 
		  <codeblock>SELECT * FROM /portfolios LIMIT 10</codeblock>If you use the limit keyword, you cannot also run operations on the
		  query result set that do any kind of summary activities, as these would be
		  meaningless. For example, trying to run 
		  <codeph>add</codeph> or 
		  <codeph>addAll</codeph> on a 
		  <codeph>SelectResults</codeph> returned from a query with a LIMIT
		  clause throws an exception. 
		</p> 
	 </section> 
	 <section id="section_9535BA3AD51340BCB7E70423DD66F254"> 
		<title>Ordering the Results</title> 
		<p>You can order your query results in ascending or descending order
		  using the ORDER BY clause. 
		</p> 
		<p>This sorts the results returned from lowest to highest market value: 
		  <codeblock>SELECT posnVal.mktValue, posnVal.secId  
  FROM /portfolios,
  positions.values posnVal TYPE Position
  WHERE status='active'
  ORDER BY posnVal.mktValue</codeblock> 
		</p> 
		<p>The default sort order is ascending. You can reverse the order with
		  the DESC keyword. This sorts the query results from highest to lowest market
		  value: 
		  <codeblock>SELECT posnVal.mktValue, posnVal.secId  
  FROM /portfolios,
  positions.values posnVal TYPE Position
  WHERE status='active'
  ORDER BY posnVal.mktValue DESC</codeblock> 
		</p> 
		<p>If you combine ORDER BY with LIMIT, the results are first ordered,
		  then the number of rows indicated by the LIMIT keyword are returned from the
		  ordered list. 
		</p> 
		<title>Caveats and Requirements for Query Order By on Partitioned
		  Regions</title> 
		<p>You can run a query using the ORDER BY clause on a partitioned region
		  with the following caveats: 
		<ul id="ul_DEE6B9F1EA064A21AE9CCED39C0FCDD0"> 
		  <li id="li_B829F7EFF2F24B219FD978C545011C7A">The fields specified in
			 the order by clause must be part of the projection list. Examples: 
			 <codeblock>// This query works because p.status is part of the projection list
select distinct p.ID, p.status from /region p where p.ID &gt; 5 order by p.status

// This query works providing status is part of the value indicated by *
select distinct * from /region where ID &gt; 5 order by status</codeblock> 
		  </li> 
		  <li id="li_BAB291C2ECF34FCF8860CCD9C5E06EF9">When an ORDER BY clause is
			 used with a partition region query, the query is executed separately on each
			 region data host, the local query coordinator and all remote members. The
			 results are all gathered by the query coordinator. The cumulative result set is
			 built by applying order by on the gathered results. If the LIMIT clause is also
			 used in the query, ORDER BY and LIMIT are applied on each host before the
			 results are returned to the coordinator. Then the clauses are applied to the
			 cumulative result set to get the final result set, which is returned to the
			 calling application. 
		  </li> 
		</ul> 
		</p> 
		<p> 
		</p> 
	 </section> 
  </conbody> 
</concept> 
